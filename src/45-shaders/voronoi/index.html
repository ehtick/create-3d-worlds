
<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js shader example - Voronoi with borders</title>
  <meta charset="utf-8">
  <style>
  body {
    margin: 0px;
    background-color: #000000;
    overflow: hidden;
  }
  .tbox {position:absolute; display:none; padding:14px 17px; z-index:900}
  .tinner {padding:15px; -moz-border-radius:5px; border-radius:5px; background:#fff url(images/preload.gif) no-repeat 50% 50%; border-right:1px solid #333; border-bottom:1px solid #333}
  .tmask {position:absolute; display:none; top:0px; left:0px; height:100%; width:100%; background:#000; z-index:800}
  .tclose {position:absolute; top:0px; right:0px; width:30px; height:30px; cursor:pointer; background:url(images/close.png) no-repeat}
  .tclose:hover {background-position:0 -30px}
  .dg .cr.function .property-name {width: 100%;}
  #description {padding: 5px; position: absolute; top: 5px; left: 5px; background-color: #ddd}
  #description p {margin: 0px;}

  </style>

</head>
<body>
<div id="description">
<p>three.js shader example - Voronoi with borders - Implementation of <a href="https://www.shadertoy.com/view/ldl3W8">Voronoi - distances</a> by <a href="http://iquilezles.org">Iñigo Quílez</a> <br/>
<a href="/">2pha</a> <a href="/blog">blog</a>   - <a href=" /blog/experimenting-threejs-shaders-and-shadermaterial/">Other three.js shader examples</a>
</p>
</div>

  <script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.


// I've not seen anybody out there computing correct cell interior distances for Voronoi
// patterns yet. That's why they cannot shade the cell interior correctly, and why you've
// never seen cell boundaries rendered correctly.

// However, here's how you do mathematically correct distances (note the equidistant and non
// degenerated grey isolines inside the cells) and hence edges (in yellow):

// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm

// Altered for a Three.js ShaderMaterial demo by Chris Brown - blog.2pha.com



varying vec2 vUv;
uniform vec3 color;
uniform vec3 borderColor;
uniform float borderWidth;
uniform float blur;
uniform float amount;

vec2 hash2( vec2 p )
{
    // procedural white noise
  return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

vec3 voronoi( in vec2 x )
{
    vec2 n = floor(x);
    vec2 f = fract(x);

    //----------------------------------
    // first pass: regular voronoi
    //----------------------------------
  vec2 mg, mr;

    float md = 8.0;
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    {
        vec2 g = vec2(float(i),float(j));
        vec2 o = hash2( n + g );
        vec2 r = g + o - f;
        float d = dot(r,r);

        if( d<md )
        {
            md = d;
            mr = r;
            mg = g;
        }
    }

    //----------------------------------
    // second pass: distance to borders
    //----------------------------------
    md = 8.0;
    for( int j=-2; j<=2; j++ )
    for( int i=-2; i<=2; i++ )
    {
        vec2 g = mg + vec2(float(i),float(j));
        vec2 o = hash2( n + g );
        vec2 r = g + o - f;

        if( dot(mr-r,mr-r)>0.00001 )
        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );
    }

    return vec3( md, mr );
}

void main() {
  vec3 c = voronoi( 8.0*(vUv*vec2(amount)) );
  // borders
  vec3 col = mix( borderColor, color, smoothstep( borderWidth/100.0, (borderWidth/100.0)+(blur/100.0), c.x ) );
  gl_FragColor = vec4(col,1.0);
}

  </script>

  <script src="main.js" type="module"></script>

</body>

</html>
